// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import "../src/Escrow.sol";

contract EscrowTest is Test {
    Escrow public escrow;

    // Addresses generated by Forge VM cheatcodes for testing
    address buyer = vm.addr(1);
    address seller = vm.addr(2);
    address arbiter = vm.addr(3);

    // Setup function to deploy escrow contract and fund buyer with initial balance
    function setUp() public {
        escrow = new Escrow();
        vm.deal(buyer, 10 ether);
    }

    // Test case for creating an escrow and funding it successfully
    function testCreateAndFundEscrow() public {
        vm.prank(buyer);
        uint256 id = escrow.createEscrow(seller, arbiter, 1 ether, block.timestamp + 1 days, "Test Escrow");

        vm.prank(buyer);
        escrow.fundEscrow{value: 1 ether}(id);

        Escrow.EscrowDetails memory details = escrow.getEscrowDetails(id);
        assertEq(uint(details.status), uint(Escrow.EscrowStatus.Funded));
        assertFalse(details.isDisputed);
    }

    // Test case to release funds from escrow by the seller after funding
    function testReleaseFunds() public {
        vm.prank(buyer);
        uint256 id = escrow.createEscrow(seller, arbiter, 1 ether, block.timestamp + 1 days, "Test");

        vm.prank(buyer);
        escrow.fundEscrow{value: 1 ether}(id);

        vm.prank(seller);
        escrow.releaseFunds(id);

        Escrow.EscrowDetails memory details = escrow.getEscrowDetails(id);
        assertEq(uint(details.status), uint(Escrow.EscrowStatus.Released));
    }

    // Test case to request a refund after the escrow deadline has passed
    function testRequestRefundAfterDeadline() public {
        uint256 startTime = 1000;
        // Move blockchain time to startTime for testing deadline logic
        vm.warp(startTime);

        // Fund buyer with sufficient ether for testing refund
        vm.deal(buyer, 2 ether);

        // Buyer creates escrow with a deadline 1 day (86400 seconds) in the future
        vm.prank(buyer);
        uint256 id = escrow.createEscrow(seller, arbiter, 1 ether, startTime + 86400, "Refund test");

        // Buyer funds the escrow with 1 ether
        vm.prank(buyer);
        escrow.fundEscrow{value: 1 ether}(id);

        // Move time forward just past the deadline
        vm.warp(startTime + 86401);

        // Logging current block time and deadline for debugging
        console.log("Current Time:", block.timestamp);
        console.log("Deadline:", escrow.getEscrowDetails(id).deadline);
        console.log("Time Difference:", block.timestamp - escrow.getEscrowDetails(id).deadline);

        // Buyer requests refund after deadline
        vm.prank(buyer);
        escrow.requestRefund(id);

        // Assert that escrow status is updated to Refunded
        Escrow.EscrowDetails memory details = escrow.getEscrowDetails(id);
        assertEq(uint(details.status), uint(Escrow.EscrowStatus.Refunded));
    }

    // Test case to resolve dispute in favor of seller by the arbiter
    function testDisputeResolutionToSeller() public {
        vm.prank(buyer);
        uint256 id = escrow.createEscrow(seller, arbiter, 1 ether, block.timestamp + 1 days, "Dispute test");

        vm.prank(buyer);
        escrow.fundEscrow{value: 1 ether}(id);

        // Arbiter resolves the dispute, deciding in favor of the seller (true)
        vm.prank(arbiter);
        escrow.resolveDispute(id, true);

        Escrow.EscrowDetails memory details = escrow.getEscrowDetails(id);
        assertEq(uint(details.status), uint(Escrow.EscrowStatus.Resolved));
        assertTrue(details.isDisputed);
    }


    
}
